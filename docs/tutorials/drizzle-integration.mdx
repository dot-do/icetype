---
title: Drizzle Integration
description: Complete guide to using IceType with Drizzle ORM for type-safe database access.
---

# Drizzle Integration

This tutorial covers the complete workflow for integrating IceType with Drizzle ORM, from schema definition to database queries.

## Why IceType + Drizzle?

Combining IceType with Drizzle ORM gives you:

- **Single source of truth** - Define schemas once, use everywhere
- **Type safety** - Full TypeScript inference for queries
- **Multi-database support** - Same schema for PostgreSQL, MySQL, and SQLite
- **Data lake integration** - Export to Iceberg for analytics

## Getting Started

### Installation

```bash
npm install icetype @icetype/core @icetype/drizzle
npm install drizzle-orm drizzle-kit
```

### Project Setup

Create a schema file that will be your single source of truth:

```typescript
// src/schema/icetype.ts
import { parseSchema } from 'icetype';

export const UserSchema = parseSchema({
  $type: 'User',
  $index: [['email'], ['createdAt']],

  id: 'uuid!',
  email: 'string#',
  name: 'string',
  bio: 'text?',
  avatarUrl: 'string?',
  isActive: 'bool = true',
  role: 'string = "user"',
  createdAt: 'timestamp',
  updatedAt: 'timestamp?',
});

export const PostSchema = parseSchema({
  $type: 'Post',
  $index: [['authorId'], ['publishedAt']],
  $fts: ['title', 'content'],

  id: 'uuid!',
  title: 'string!',
  slug: 'string#',
  content: 'text?',
  excerpt: 'string?',
  published: 'bool = false',
  authorId: 'uuid!',
  author: '-> User!',
  tags: 'string[]',
  viewCount: 'int = 0',
  publishedAt: 'timestamp?',
  createdAt: 'timestamp',
  updatedAt: 'timestamp?',
});

export const CommentSchema = parseSchema({
  $type: 'Comment',
  $index: [['postId'], ['authorId']],

  id: 'uuid!',
  content: 'text!',
  postId: 'uuid!',
  post: '-> Post!',
  authorId: 'uuid!',
  author: '-> User!',
  createdAt: 'timestamp',
});

export const schemas = [UserSchema, PostSchema, CommentSchema];
```

## Generating Drizzle Schemas

### Using the API

```typescript
// scripts/generate-drizzle.ts
import { transformSchemasToDrizzle } from '@icetype/drizzle';
import { schemas } from '../src/schema/icetype';
import { writeFileSync } from 'fs';

// Generate for PostgreSQL
const pgSchema = transformSchemasToDrizzle(schemas, {
  dialect: 'pg',
  camelCase: true,
});

writeFileSync('./src/db/schema.ts', pgSchema);
console.log('Generated Drizzle schema for PostgreSQL');
```

### Generated Output

The generated Drizzle schema:

```typescript
/**
 * Drizzle ORM Schema
 *
 * Generated by @icetype/drizzle
 *
 * Dialect: pg
 */

import {
  boolean,
  index,
  integer,
  pgTable,
  text,
  timestamp,
  uuid,
  varchar,
} from 'drizzle-orm/pg-core';

export const user = pgTable('user', {
  id: uuid('id').primaryKey().notNull().defaultRandom(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  name: varchar('name', { length: 255 }).notNull(),
  bio: text('bio'),
  avatarUrl: varchar('avatarUrl', { length: 255 }),
  isActive: boolean('isActive').notNull().default(true),
  role: varchar('role', { length: 255 }).notNull().default('user'),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt'),
}, (table) => ({
  emailIdx: index('user_email_idx').on(table.email),
  createdAtIdx: index('user_createdAt_idx').on(table.createdAt),
}));

export const post = pgTable('post', {
  id: uuid('id').primaryKey().notNull().defaultRandom(),
  title: varchar('title', { length: 255 }).notNull(),
  slug: varchar('slug', { length: 255 }).notNull().unique(),
  content: text('content'),
  excerpt: varchar('excerpt', { length: 255 }),
  published: boolean('published').notNull().default(false),
  authorId: uuid('authorId').notNull().references(() => user.id),
  tags: varchar('tags', { length: 255 }).array(),
  viewCount: integer('viewCount').notNull().default(0),
  publishedAt: timestamp('publishedAt'),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt'),
}, (table) => ({
  authorIdIdx: index('post_authorId_idx').on(table.authorId),
  publishedAtIdx: index('post_publishedAt_idx').on(table.publishedAt),
}));

export const comment = pgTable('comment', {
  id: uuid('id').primaryKey().notNull().defaultRandom(),
  content: text('content').notNull(),
  postId: uuid('postId').notNull().references(() => post.id),
  authorId: uuid('authorId').notNull().references(() => user.id),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
}, (table) => ({
  postIdIdx: index('comment_postId_idx').on(table.postId),
  authorIdIdx: index('comment_authorId_idx').on(table.authorId),
}));

export type User = typeof user.$inferSelect;
export type NewUser = typeof user.$inferInsert;
export type Post = typeof post.$inferSelect;
export type NewPost = typeof post.$inferInsert;
export type Comment = typeof comment.$inferSelect;
export type NewComment = typeof comment.$inferInsert;
```

## Database Configuration

### PostgreSQL Setup

```typescript
// src/db/index.ts
import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';
import * as schema from './schema';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

export const db = drizzle(pool, { schema });
```

### SQLite Setup

Generate for SQLite if you need a local development database:

```typescript
// scripts/generate-drizzle-sqlite.ts
import { transformSchemasToDrizzle } from '@icetype/drizzle';
import { schemas } from '../src/schema/icetype';
import { writeFileSync } from 'fs';

const sqliteSchema = transformSchemasToDrizzle(schemas, {
  dialect: 'sqlite',
});

writeFileSync('./src/db/schema.sqlite.ts', sqliteSchema);
```

```typescript
// src/db/sqlite.ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';
import * as schema from './schema.sqlite';

const sqlite = new Database('local.db');
export const db = drizzle(sqlite, { schema });
```

### MySQL Setup

```typescript
import { transformSchemasToDrizzle } from '@icetype/drizzle';

const mysqlSchema = transformSchemasToDrizzle(schemas, {
  dialect: 'mysql',
});
```

## Querying with Drizzle

### Basic Queries

```typescript
import { db } from './db';
import { user, post, comment } from './db/schema';
import { eq, desc, and, like, sql } from 'drizzle-orm';

// Find all users
const users = await db.select().from(user);

// Find user by email
const [foundUser] = await db
  .select()
  .from(user)
  .where(eq(user.email, 'user@example.com'));

// Find published posts
const publishedPosts = await db
  .select()
  .from(post)
  .where(eq(post.published, true))
  .orderBy(desc(post.publishedAt));

// Search posts by title
const searchResults = await db
  .select()
  .from(post)
  .where(like(post.title, '%typescript%'));
```

### Joins and Relations

```typescript
// Get posts with author information
const postsWithAuthors = await db
  .select({
    post: post,
    author: user,
  })
  .from(post)
  .innerJoin(user, eq(post.authorId, user.id))
  .where(eq(post.published, true));

// Get post with comments
const postWithComments = await db
  .select({
    post: post,
    comment: comment,
    commentAuthor: user,
  })
  .from(post)
  .leftJoin(comment, eq(comment.postId, post.id))
  .leftJoin(user, eq(comment.authorId, user.id))
  .where(eq(post.slug, 'my-post-slug'));
```

### Inserts and Updates

```typescript
import { NewUser, NewPost } from './db/schema';

// Insert a new user
const newUser: NewUser = {
  email: 'new@example.com',
  name: 'New User',
};

const [insertedUser] = await db
  .insert(user)
  .values(newUser)
  .returning();

// Insert a new post
const newPost: NewPost = {
  title: 'My First Post',
  slug: 'my-first-post',
  content: 'This is the content...',
  authorId: insertedUser.id,
};

await db.insert(post).values(newPost);

// Update a user
await db
  .update(user)
  .set({ isActive: false, updatedAt: new Date() })
  .where(eq(user.id, insertedUser.id));

// Increment view count
await db
  .update(post)
  .set({ viewCount: sql`${post.viewCount} + 1` })
  .where(eq(post.slug, 'my-first-post'));
```

## Migrations with Drizzle Kit

### Configuration

```typescript
// drizzle.config.ts
import type { Config } from 'drizzle-kit';

export default {
  schema: './src/db/schema.ts',
  out: './drizzle/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
} satisfies Config;
```

### Migration Workflow

```bash
# Generate migration after schema changes
npx drizzle-kit generate

# Apply migrations
npx drizzle-kit migrate

# Or use push for development
npx drizzle-kit push
```

## Workflow Automation

### Build Script

Create a script that regenerates Drizzle schemas when IceType schemas change:

```typescript
// scripts/build-schemas.ts
import { transformSchemasToDrizzle } from '@icetype/drizzle';
import { transformToPostgresDDL } from '@icetype/postgres';
import { generateIcebergMetadata } from '@icetype/iceberg';
import { schemas } from '../src/schema/icetype';
import { writeFileSync, mkdirSync } from 'fs';

// Ensure output directories exist
mkdirSync('./src/db', { recursive: true });
mkdirSync('./generated', { recursive: true });

// Generate Drizzle schema
const drizzleSchema = transformSchemasToDrizzle(schemas, {
  dialect: 'pg',
  camelCase: true,
});
writeFileSync('./src/db/schema.ts', drizzleSchema);
console.log('Generated: src/db/schema.ts');

// Generate PostgreSQL DDL (for reference/manual migrations)
const ddl = schemas
  .map(s => transformToPostgresDDL(s, { ifNotExists: true }))
  .join('\n\n');
writeFileSync('./generated/schema.sql', ddl);
console.log('Generated: generated/schema.sql');

// Generate Iceberg metadata for data lake
for (const schema of schemas) {
  const metadata = generateIcebergMetadata(
    schema,
    `s3://data-lake/${schema.name.toLowerCase()}`
  );
  writeFileSync(
    `./generated/${schema.name.toLowerCase()}-iceberg.json`,
    JSON.stringify(metadata, null, 2)
  );
}
console.log('Generated: Iceberg metadata files');
```

### npm Scripts

```json
{
  "scripts": {
    "schema:build": "tsx scripts/build-schemas.ts",
    "schema:watch": "tsx watch scripts/build-schemas.ts",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  }
}
```

## Advanced Patterns

### Custom Type Handling

Override type mappings for specific needs:

```typescript
import { transformSchemasToDrizzle } from '@icetype/drizzle';

const schema = transformSchemasToDrizzle(schemas, {
  dialect: 'pg',
  // Custom mappings
  customTypeMappings: {
    'money': 'decimal',
    'ip': 'varchar',
  },
});
```

### Soft Deletes

Add soft delete support:

```typescript
const UserSchema = parseSchema({
  $type: 'User',
  $index: [['email'], ['deletedAt']],

  id: 'uuid!',
  email: 'string#',
  name: 'string',
  deletedAt: 'timestamp?',  // Soft delete marker
  createdAt: 'timestamp',
});
```

Query active records:

```typescript
import { isNull } from 'drizzle-orm';

const activeUsers = await db
  .select()
  .from(user)
  .where(isNull(user.deletedAt));
```

### Multi-Tenancy

```typescript
const TenantSchema = parseSchema({
  $type: 'Tenant',
  id: 'uuid!',
  name: 'string!',
  slug: 'string#',
});

const UserSchema = parseSchema({
  $type: 'User',
  $partitionBy: ['tenantId'],
  $index: [['tenantId', 'email']],

  id: 'uuid!',
  tenantId: 'uuid!',
  tenant: '-> Tenant!',
  email: 'string!',
  name: 'string',
});
```

Query with tenant isolation:

```typescript
const tenantId = getCurrentTenantId();

const users = await db
  .select()
  .from(user)
  .where(eq(user.tenantId, tenantId));
```

### Audit Logging

```typescript
const AuditLogSchema = parseSchema({
  $type: 'AuditLog',
  $partitionBy: ['createdAt'],
  $index: [['entityType', 'entityId'], ['userId'], ['createdAt']],

  id: 'uuid!',
  entityType: 'string!',
  entityId: 'uuid!',
  action: 'string!',       // 'create' | 'update' | 'delete'
  userId: 'uuid!',
  changes: 'json',
  createdAt: 'timestamp',
});
```

## Testing

### Test Database Setup

```typescript
// tests/setup.ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
import * as schema from '../src/db/schema.sqlite';

export function createTestDb() {
  const sqlite = new Database(':memory:');
  const db = drizzle(sqlite, { schema });

  // Apply migrations
  migrate(db, { migrationsFolder: './drizzle/migrations' });

  return db;
}
```

### Writing Tests

```typescript
// tests/user.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { createTestDb } from './setup';
import { user } from '../src/db/schema.sqlite';
import { eq } from 'drizzle-orm';

describe('User', () => {
  let db: ReturnType<typeof createTestDb>;

  beforeEach(() => {
    db = createTestDb();
  });

  it('should create a user', async () => {
    const [newUser] = await db
      .insert(user)
      .values({
        email: 'test@example.com',
        name: 'Test User',
      })
      .returning();

    expect(newUser.email).toBe('test@example.com');
    expect(newUser.isActive).toBe(true);
  });

  it('should find user by email', async () => {
    await db.insert(user).values({
      email: 'find@example.com',
      name: 'Find User',
    });

    const [found] = await db
      .select()
      .from(user)
      .where(eq(user.email, 'find@example.com'));

    expect(found).toBeDefined();
    expect(found.name).toBe('Find User');
  });
});
```

## Next Steps

- [Migration Workflow](/tutorials/migration-workflow) - Migrate existing schemas to IceType
- [Iceberg Analytics](/tutorials/iceberg-analytics) - Set up data lake integration
- [API Reference: Drizzle](/api/drizzle) - Complete Drizzle adapter API
