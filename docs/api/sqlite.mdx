---
title: "@icetype/sqlite API"
description: API reference for the @icetype/sqlite package - SQLite DDL generation from IceType schemas.
---

# @icetype/sqlite API

The `@icetype/sqlite` package transforms IceType schemas to SQLite DDL (Data Definition Language) statements. SQLite is a lightweight, embedded relational database ideal for local storage, mobile apps, edge computing, and Cloudflare Durable Objects.

## Installation

```bash
npm install @icetype/sqlite
# or
pnpm add @icetype/sqlite
```

## Quick Start

```typescript
import { parseSchema } from '@icetype/core';
import { SQLiteAdapter, transformToSQLiteDDL } from '@icetype/sqlite';

// Parse an IceType schema
const schema = parseSchema({
  $type: 'User',
  id: 'uuid!',
  email: 'string#',
  name: 'string',
  age: 'int?',
  active: 'bool',
  createdAt: 'timestamp',
});

// Option 1: Use the adapter directly
const adapter = new SQLiteAdapter();
const ddl = adapter.transform(schema, { ifNotExists: true });
const sql = adapter.serialize(ddl);

// Option 2: Use the convenience function
const sql2 = transformToSQLiteDDL(schema, {
  ifNotExists: true,
  strict: true,
});

console.log(sql2);
// CREATE TABLE IF NOT EXISTS User (
//   "$id" TEXT NOT NULL PRIMARY KEY,
//   "$type" TEXT NOT NULL,
//   "$version" INTEGER NOT NULL DEFAULT 1,
//   "$createdAt" INTEGER NOT NULL,
//   "$updatedAt" INTEGER NOT NULL,
//   id TEXT NOT NULL,
//   email TEXT UNIQUE,
//   name TEXT,
//   age INTEGER,
//   active INTEGER,
//   createdAt TEXT,
//   UNIQUE (email)
// ) STRICT;
```

## SQLiteAdapter Class

The main adapter class that implements the `SchemaAdapter` interface.

### Constructor

```typescript
import { SQLiteAdapter } from '@icetype/sqlite';

const adapter = new SQLiteAdapter();
```

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `name` | `string` | `'sqlite'` - Adapter identifier |
| `version` | `string` | `'0.1.0'` - Adapter version |

### Methods

#### `transform(schema, options?)`

Transforms an IceType schema to a SQLite DDL structure.

```typescript
const ddl = adapter.transform(schema, {
  ifNotExists: true,
  strict: true,
  includeSystemFields: true,
});
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `schema` | `IceTypeSchema` | Parsed IceType schema |
| `options` | `SQLiteAdapterOptions` | Optional configuration |

**Returns:** `SQLiteDDL`

---

#### `serialize(output)`

Serializes a SQLite DDL structure to a CREATE TABLE SQL statement.

```typescript
const sql = adapter.serialize(ddl);
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `output` | `SQLiteDDL` | DDL structure to serialize |

**Returns:** `string` - SQL CREATE TABLE statement

---

#### `serializeWithIndexes(ddl)`

Generates DDL including CREATE INDEX statements for indexed columns.

```typescript
const sqlWithIndexes = adapter.serializeWithIndexes(ddl);
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `ddl` | `SQLiteDDL` | DDL structure |

**Returns:** `string` - Full DDL including CREATE INDEX statements

## Convenience Functions

### `createSQLiteAdapter()`

Factory function to create a new SQLite adapter instance.

```typescript
import { createSQLiteAdapter } from '@icetype/sqlite';

const adapter = createSQLiteAdapter();
```

**Returns:** `SQLiteAdapter`

---

### `transformToSQLiteDDL(schema, options?)`

Transforms an IceType schema directly to a SQLite CREATE TABLE statement.

```typescript
import { parseSchema } from '@icetype/core';
import { transformToSQLiteDDL } from '@icetype/sqlite';

const schema = parseSchema({
  $type: 'User',
  id: 'uuid!',
  email: 'string#',
});

const sql = transformToSQLiteDDL(schema, { ifNotExists: true });
console.log(sql);
// CREATE TABLE IF NOT EXISTS User (
//   ...
// );
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `schema` | `IceTypeSchema` | Parsed IceType schema |
| `options` | `SQLiteAdapterOptions` | Optional configuration |

**Returns:** `string` - SQL CREATE TABLE statement

---

### `generateSQLiteDDL(schema, options?)`

Transforms an IceType schema to a SQLite DDL structure (without serializing to SQL).

```typescript
import { generateSQLiteDDL } from '@icetype/sqlite';

const ddl = generateSQLiteDDL(schema, {
  tableName: 'users',
  withoutRowid: true,
});
```

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `schema` | `IceTypeSchema` | Parsed IceType schema |
| `options` | `SQLiteAdapterOptions` | Optional configuration |

**Returns:** `SQLiteDDL`

## DDL Helper Functions

### `mapIceTypeToSQLite(iceType, field?)`

Maps an IceType type to its SQLite equivalent storage class.

```typescript
import { mapIceTypeToSQLite } from '@icetype/sqlite';

const mapping = mapIceTypeToSQLite('string');
// { sqliteType: 'TEXT' }

const intMapping = mapIceTypeToSQLite('int');
// { sqliteType: 'INTEGER' }
```

---

### `getSQLiteTypeString(mapping)`

Gets the SQLite type string from a type mapping.

```typescript
import { getSQLiteTypeString } from '@icetype/sqlite';

const typeStr = getSQLiteTypeString({ sqliteType: 'INTEGER' });
// 'INTEGER'
```

---

### `fieldToSQLiteColumn(name, field)`

Converts an IceType field definition to a SQLite column definition.

```typescript
import { fieldToSQLiteColumn } from '@icetype/sqlite';
import { parseField } from '@icetype/core';

const field = parseField('string#');
const column = fieldToSQLiteColumn('email', field);
// { name: 'email', type: 'TEXT', nullable: false, unique: true }
```

---

### `escapeIdentifier(identifier)`

Escapes a SQLite identifier (table or column name) using double quotes when necessary.

```typescript
import { escapeIdentifier } from '@icetype/sqlite';

const escaped = escapeIdentifier('$id');
// '"$id"'

const simple = escapeIdentifier('name');
// 'name' (no escaping needed)
```

---

### `serializeColumn(column)`

Serializes a column definition to a DDL fragment.

```typescript
import { serializeColumn } from '@icetype/sqlite';

const sql = serializeColumn({
  name: 'email',
  type: 'TEXT',
  nullable: false,
  unique: true,
});
// 'email TEXT NOT NULL UNIQUE'
```

---

### `serializeDDL(ddl)`

Serializes a complete DDL structure to SQL.

```typescript
import { serializeDDL } from '@icetype/sqlite';

const sql = serializeDDL(ddl);
```

---

### `generateIndexStatements(tableName, columns)`

Generates CREATE INDEX statements for indexed columns.

```typescript
import { generateIndexStatements } from '@icetype/sqlite';

const indexes = generateIndexStatements('users', columns);
// ['CREATE INDEX "idx_users_email" ON users ("email");']
```

---

### `generateSystemColumns()`

Generates the standard IceType system field columns for SQLite tables.

```typescript
import { generateSystemColumns } from '@icetype/sqlite';

const systemCols = generateSystemColumns();
// Returns columns for $id, $type, $version, $createdAt, $updatedAt
```

---

### `formatDefaultValue(value, type)`

Formats a default value as a SQL expression.

```typescript
import { formatDefaultValue } from '@icetype/sqlite';

formatDefaultValue('hello', 'TEXT');    // "'hello'"
formatDefaultValue(42, 'INTEGER');       // '42'
formatDefaultValue(true, 'INTEGER');     // '1'
formatDefaultValue(false, 'INTEGER');    // '0'
formatDefaultValue(null, 'TEXT');        // 'NULL'
```

## Options Reference

### `SQLiteAdapterOptions`

Options for the SQLite adapter.

```typescript
interface SQLiteAdapterOptions {
  // Override the table name (defaults to schema name)
  tableName?: string;

  // Add IF NOT EXISTS clause
  ifNotExists?: boolean;

  // Include system fields ($id, $type, $version, $createdAt, $updatedAt)
  includeSystemFields?: boolean;  // default: true

  // Use WITHOUT ROWID optimization (table must have PRIMARY KEY)
  withoutRowid?: boolean;

  // Use STRICT mode for type enforcement (SQLite 3.37+)
  strict?: boolean;
}
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `tableName` | `string` | Schema name | Override the generated table name |
| `ifNotExists` | `boolean` | `undefined` | Add `IF NOT EXISTS` clause |
| `includeSystemFields` | `boolean` | `true` | Include IceType system columns |
| `withoutRowid` | `boolean` | `undefined` | Use WITHOUT ROWID optimization |
| `strict` | `boolean` | `undefined` | Enable STRICT mode (SQLite 3.37+) |

## SQLite-Specific Features

### STRICT Mode

SQLite 3.37+ introduced STRICT mode for type enforcement. By default, SQLite uses dynamic typing where any column can store any type. STRICT mode enforces that values match the declared column type.

```typescript
const sql = transformToSQLiteDDL(schema, {
  strict: true,
});
// CREATE TABLE User (
//   ...
// ) STRICT;
```

**Benefits of STRICT mode:**
- Type safety: Prevents storing wrong types in columns
- Data integrity: Catches type errors at insert time
- Performance: Optimizes storage for known types

**Requirements:**
- SQLite 3.37.0 or later (released November 2021)
- Compatible with Cloudflare Durable Objects SQLite

### WITHOUT ROWID

The WITHOUT ROWID optimization creates a table without the implicit `rowid` column, which can improve performance for tables that use their primary key directly.

```typescript
const sql = transformToSQLiteDDL(schema, {
  withoutRowid: true,
});
// CREATE TABLE User (
//   ...
// ) WITHOUT ROWID;
```

**Best used when:**
- The table has a natural primary key
- Primary key lookups are the primary access pattern
- You want to avoid the storage overhead of the rowid column

**Note:** WITHOUT ROWID tables must have a PRIMARY KEY defined.

### Combined Options

You can combine STRICT and WITHOUT ROWID:

```typescript
const sql = transformToSQLiteDDL(schema, {
  ifNotExists: true,
  withoutRowid: true,
  strict: true,
});
// CREATE TABLE IF NOT EXISTS User (
//   ...
// ) WITHOUT ROWID, STRICT;
```

## Type Mappings

SQLite uses a simplified type system with only **four storage classes** (plus NULL):

| Storage Class | Description |
|---------------|-------------|
| `INTEGER` | Signed integer (1, 2, 3, 4, 6, or 8 bytes) |
| `REAL` | 8-byte IEEE floating point number |
| `TEXT` | UTF-8, UTF-16BE, or UTF-16LE string |
| `BLOB` | Binary data stored exactly as input |

### IceType to SQLite Mappings

| IceType | SQLite | Notes |
|---------|--------|-------|
| `string` | `TEXT` | UTF-8 string |
| `text` | `TEXT` | Alias for string |
| `varchar` | `TEXT` | Alias for string |
| `int` | `INTEGER` | 32-bit signed integer |
| `long` | `INTEGER` | 64-bit signed integer |
| `bigint` | `INTEGER` | 64-bit signed integer |
| `float` | `REAL` | 32-bit floating point |
| `double` | `REAL` | 64-bit floating point |
| `bool` | `INTEGER` | Stored as 0 or 1 |
| `boolean` | `INTEGER` | Stored as 0 or 1 |
| `uuid` | `TEXT` | Stored as string (no native UUID type) |
| `timestamp` | `TEXT` | ISO8601 format string |
| `timestamptz` | `TEXT` | ISO8601 format with timezone |
| `date` | `TEXT` | ISO8601 date string |
| `time` | `TEXT` | Time string |
| `json` | `TEXT` | JSON string (use json1 extension) |
| `binary` | `BLOB` | Binary data |
| `decimal` | `REAL` | No native decimal type |

**Important differences from other databases:**

- **No native UUID type**: UUIDs are stored as TEXT strings
- **No native boolean type**: Booleans are stored as INTEGER (0 or 1)
- **No native date/time types**: Dates and times are stored as TEXT (ISO8601) or INTEGER (Unix epoch)
- **No native JSON type**: JSON is stored as TEXT but can be queried with json1 extension functions
- **No DECIMAL/NUMERIC**: High-precision decimals are stored as REAL (may lose precision)
- **No native array type**: Arrays are stored as JSON in TEXT columns (see below)

### Array Type Handling

SQLite does not have native array support. When you define array fields in your IceType schema (e.g., `string[]`, `int[]`), the SQLite adapter will:

1. **Store arrays as JSON in TEXT columns**: Array data is serialized to JSON format
2. **Generate a warning**: The adapter logs a warning and includes it in the DDL result
3. **Recommend JSON functions**: Use SQLite's json1 extension functions to query array data

```typescript
const schema = parseSchema({
  $type: 'Article',
  id: 'uuid!',
  title: 'string!',
  tags: 'string[]',      // Warning: stored as JSON in TEXT
  scores: 'int[]',       // Warning: stored as JSON in TEXT
});

const adapter = new SQLiteAdapter();
const ddl = adapter.transform(schema);

// Check for warnings
if (ddl.warnings) {
  for (const warning of ddl.warnings) {
    console.log(`[${warning.code}] ${warning.fieldName}: ${warning.message}`);
  }
}
// Output:
// [SQLITE_ARRAY_AS_JSON] tags: SQLite does not have native array support...
// [SQLITE_ARRAY_AS_JSON] scores: SQLite does not have native array support...
```

**Querying array data with json1 functions:**

```sql
-- Insert array data as JSON
INSERT INTO Article (tags) VALUES ('["typescript", "database", "schema"]');

-- Query array elements
SELECT * FROM Article WHERE json_extract(tags, '$[0]') = 'typescript';

-- Expand array to rows
SELECT Article.*, value as tag
FROM Article, json_each(Article.tags);

-- Check if array contains value
SELECT * FROM Article
WHERE EXISTS (
  SELECT 1 FROM json_each(Article.tags) WHERE value = 'database'
);
```

## Types

### `SQLiteDDL`

The DDL structure containing all information for table creation.

```typescript
interface SQLiteDDL {
  tableName: string;
  columns: SQLiteColumn[];
  primaryKey?: string[];
  uniqueConstraints?: string[][];
  ifNotExists?: boolean;
  withoutRowid?: boolean;
  strict?: boolean;
  checkConstraints?: Array<{
    name?: string;
    expression: string;
  }>;
  foreignKeys?: Array<{
    columns: string[];
    references: {
      table: string;
      columns: string[];
    };
    onDelete?: 'CASCADE' | 'SET NULL' | 'SET DEFAULT' | 'RESTRICT' | 'NO ACTION';
    onUpdate?: 'CASCADE' | 'SET NULL' | 'SET DEFAULT' | 'RESTRICT' | 'NO ACTION';
  }>;
  warnings?: SQLiteDDLWarning[];  // Warnings generated during transformation
}
```

### `SQLiteDDLWarning`

Warning message generated during DDL transformation.

```typescript
interface SQLiteDDLWarning {
  fieldName: string;  // The field that triggered the warning
  message: string;    // Human-readable warning message
  code: string;       // Warning code for programmatic handling
}
```

**Warning Codes:**

| Code | Description |
|------|-------------|
| `SQLITE_ARRAY_AS_JSON` | Array type field will be stored as JSON in a TEXT column |

### `SQLiteColumn`

Column definition for DDL generation.

```typescript
interface SQLiteColumn {
  name: string;
  type: string;
  nullable: boolean;
  default?: string;
  primaryKey?: boolean;
  unique?: boolean;
  autoIncrement?: boolean;
}
```

### `SQLiteType`

Union of SQLite native storage classes.

```typescript
type SQLiteType = 'INTEGER' | 'REAL' | 'TEXT' | 'BLOB';
```

### `SQLiteTypeMapping`

Configuration for mapping IceType types to SQLite types.

```typescript
interface SQLiteTypeMapping {
  sqliteType: string;
}
```

## System Columns

When `includeSystemFields` is `true` (the default), the following system columns are added:

| Column | Type | Description |
|--------|------|-------------|
| `$id` | `TEXT NOT NULL PRIMARY KEY` | Primary key identifier |
| `$type` | `TEXT NOT NULL` | Entity type name |
| `$version` | `INTEGER NOT NULL DEFAULT 1` | Optimistic concurrency version |
| `$createdAt` | `INTEGER NOT NULL` | Creation timestamp (Unix epoch ms) |
| `$updatedAt` | `INTEGER NOT NULL` | Last update timestamp (Unix epoch ms) |

## Use Cases

### Cloudflare Durable Objects

SQLite is the storage engine for Cloudflare Durable Objects. Use IceType to define schemas for DO-based applications:

```typescript
import { parseSchema } from '@icetype/core';
import { transformToSQLiteDDL } from '@icetype/sqlite';

const schema = parseSchema({
  $type: 'Session',
  userId: 'string!',
  token: 'string#',
  expiresAt: 'timestamp',
  metadata: 'json',
});

const sql = transformToSQLiteDDL(schema, {
  ifNotExists: true,
  strict: true,
});

// Use in Durable Object
export class SessionDO implements DurableObject {
  constructor(private state: DurableObjectState) {
    state.storage.sql.exec(sql);
  }
}
```

### Mobile Applications

SQLite is the go-to database for mobile apps. IceType schemas provide type safety:

```typescript
const schema = parseSchema({
  $type: 'Note',
  id: 'uuid!',
  title: 'string!',
  content: 'text',
  tags: 'json',
  isFavorite: 'bool',
  createdAt: 'timestamp',
  updatedAt: 'timestamp',
});

const ddl = transformToSQLiteDDL(schema, {
  ifNotExists: true,
  strict: true,  // Type safety
});
```

### Embedded Applications

For embedded systems and local-first applications:

```typescript
const schema = parseSchema({
  $type: 'SensorReading',
  deviceId: 'string!',
  timestamp: 'timestamp!',
  temperature: 'double',
  humidity: 'double',
  pressure: 'double',
});

const ddl = transformToSQLiteDDL(schema, {
  ifNotExists: true,
  withoutRowid: true,  // Optimize for primary key access
});
```

### Local Development

Use SQLite for local development before deploying to production:

```typescript
const schema = parseSchema({
  $type: 'User',
  id: 'uuid!',
  email: 'string#',
  name: 'string',
  role: 'string',
});

// Development: SQLite
const sqliteDDL = transformToSQLiteDDL(schema, {
  ifNotExists: true,
});

// Production: PostgreSQL, DuckDB, etc.
// Use the same IceType schema with different adapters
```

### JSON Data Storage

SQLite's json1 extension allows querying JSON data:

```typescript
const schema = parseSchema({
  $type: 'Event',
  id: 'uuid!',
  type: 'string!',
  payload: 'json',
  metadata: 'json',
  timestamp: 'timestamp',
});

const ddl = transformToSQLiteDDL(schema, {
  ifNotExists: true,
});

// Query JSON fields using SQLite json1 functions:
// SELECT * FROM Event WHERE json_extract(payload, '$.userId') = 'abc123';
```
