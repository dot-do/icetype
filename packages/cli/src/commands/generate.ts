/**
 * ice generate command
 *
 * Generates TypeScript types from IceType schemas.
 */

import { writeFileSync } from 'node:fs';
import { parseArgs } from 'node:util';
import type { IceTypeSchema, FieldDefinition } from '@icetype/core';
import { loadSchemaFile } from '../utils/schema-loader.js';

export async function generate(args: string[]) {
  const { values } = parseArgs({
    args,
    options: {
      schema: { type: 'string', short: 's' },
      output: { type: 'string', short: 'o' },
    },
  });

  if (!values.schema) {
    console.error('Error: --schema is required');
    console.log('Usage: ice generate --schema ./schema.ts --output ./types.ts');
    process.exit(1);
  }

  // values.schema is guaranteed to be string after the check above
  const schemaPath = values.schema;
  const outputPath = typeof values.output === 'string' ? values.output : schemaPath.replace(/\.(ts|js|mjs|json)$/, '.generated.ts');

  console.log(`Generating types from: ${schemaPath}`);

  try {
    // Load schemas from the file
    const loadResult = await loadSchemaFile(schemaPath);

    // Check for loading errors
    if (loadResult.errors.length > 0) {
      for (const error of loadResult.errors) {
        console.error(error);
      }
      process.exit(1);
    }

    if (loadResult.schemas.length === 0) {
      console.error('No schemas found in the file');
      process.exit(1);
    }

    console.log(`Found ${loadResult.schemas.length} schema(s)`);

    // Generate types for all schemas
    const types = generateTypesFromSchemas(loadResult.schemas.map(s => s.schema));

    try {
      writeFileSync(outputPath, types);
      console.log(`Generated types: ${outputPath}`);
    } catch (writeError) {
      const message = writeError instanceof Error ? writeError.message : String(writeError);
      console.error(`Error: Failed to write output file '${outputPath}': ${message}`);
      console.error('Check that the directory exists and you have write permissions.');
      process.exit(1);
    }
  } catch (error) {
    console.error('Error generating types:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

/**
 * Generate TypeScript types from multiple schemas
 */
function generateTypesFromSchemas(schemas: IceTypeSchema[]): string {
  const lines: string[] = [];

  lines.push(`/**`);
  lines.push(` * IceType Generated Types`);
  lines.push(` *`);
  lines.push(` * This file was generated by 'ice generate'.`);
  lines.push(` * Do not edit manually - changes will be overwritten.`);
  lines.push(` *`);
  lines.push(` * @generated`);
  lines.push(` */`);
  lines.push(``);

  for (const schema of schemas) {
    lines.push(generateTypeScriptInterface(schema));
    lines.push(``);
  }

  return lines.join('\n');
}

/**
 * Generate TypeScript interface from IceType schema
 */
export function generateTypeScriptInterface(schema: IceTypeSchema): string {
  const lines: string[] = [];

  lines.push(`/**`);
  lines.push(` * Generated from IceType schema: ${schema.name}`);
  lines.push(` * @generated`);
  lines.push(` */`);
  lines.push(``);

  // Generate the interface
  lines.push(`export interface ${schema.name} {`);

  // System fields
  lines.push(`  /** Unique document identifier */`);
  lines.push(`  $id: string;`);
  lines.push(`  /** Document type */`);
  lines.push(`  $type: '${schema.name}';`);
  lines.push(`  /** Document version */`);
  lines.push(`  $version: number;`);
  lines.push(`  /** Creation timestamp (epoch ms) */`);
  lines.push(`  $createdAt: number;`);
  lines.push(`  /** Last update timestamp (epoch ms) */`);
  lines.push(`  $updatedAt: number;`);

  // User fields
  for (const [fieldName, field] of schema.fields) {
    if (fieldName.startsWith('$')) continue;

    const tsType = fieldToTypeScript(field);
    const optional = field.isOptional ? '?' : '';
    lines.push(`  ${fieldName}${optional}: ${tsType};`);
  }

  lines.push(`}`);

  // Generate input type (without system fields)
  lines.push(``);
  lines.push(`/** Input type for creating ${schema.name} */`);
  lines.push(`export interface ${schema.name}Input {`);

  for (const [fieldName, field] of schema.fields) {
    if (fieldName.startsWith('$')) continue;

    const tsType = fieldToTypeScript(field);
    const optional = field.isOptional || field.defaultValue !== undefined ? '?' : '';
    lines.push(`  ${fieldName}${optional}: ${tsType};`);
  }

  lines.push(`}`);

  return lines.join('\n');
}

/**
 * Convert IceType field to TypeScript type
 */
function fieldToTypeScript(field: FieldDefinition): string {
  if (field.relation) {
    // Relations become string IDs or arrays of string IDs
    if (field.isArray) {
      return 'string[]';
    }
    return 'string';
  }

  let baseType: string;

  switch (field.type.toLowerCase()) {
    case 'string':
    case 'text':
    case 'uuid':
      baseType = 'string';
      break;
    case 'int':
    case 'long':
    case 'bigint':
    case 'float':
    case 'double':
    case 'decimal':
      baseType = 'number';
      break;
    case 'bool':
    case 'boolean':
      baseType = 'boolean';
      break;
    case 'timestamp':
    case 'timestamptz':
    case 'date':
    case 'time':
      baseType = 'number'; // Epoch ms
      break;
    case 'json':
      baseType = 'unknown';
      break;
    case 'binary':
      baseType = 'Uint8Array';
      break;
    default:
      baseType = 'unknown';
  }

  if (field.isArray) {
    return `${baseType}[]`;
  }

  return baseType;
}

